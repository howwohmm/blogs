{"pageProps":{"postData":{"slug":"creating-reusable-dev-environments-with-sandboxes","title":"Creating reusable developer environments with Stripe Sandboxes","summary":"When onboarding new team members, getting their development environments setup can be very time consuming. Preprovisioned environments with Stripe sandboxes and development containers can speed up their time to productivity.","authors":["Cecil Phillip"],"date":"2024-10-20","type":"Blog","topics":["Sandboxes"],"artConfig":{"ampX":0.5330209860971548,"ampY":0.3805387571353413,"aspectRatio":0.41516675978899176,"axis":"x","lump":0,"count":34.20000000000001,"freq":2.19048980999072,"isDial":false,"isLineart":false,"isRing":false,"isSpiral":false,"left":0,"mouseX":0.7386574074074074,"mouseY":0.52,"noise":0,"scale":1.2797443644167636,"top":30,"twirl":0.2139585743169172,"twist":5.989515467478382,"velocity":1,"shape":"rect"},"content":"\nWhen new software engineers join a team, it can take weeks to set up development machines with the right configuration of tools, permissions, and project dependencies. However, technologies such as containerization and cloud-based development environments can reduce the time it takes for new engineers to start being productive by using pre-configured development environments that spin up relatively quickly. These environments also come with the added benefit of helping enforce consistency across the team regarding operating system, runtime, and library versions. \n\nIf your project includes a payment integration with Stripe, pairing these development environments with [Stripe Sandboxes](https://docs.stripe.com/sandboxes) provides engineers with a safe, isolated workspace where they can observe and experiment on the project without disrupting live data. \n\nWithin a Stripe sandbox account, engineers have full access to the Stripe API and can test payment functionality without needing to execute real transactions. Sandboxes can be populated with account data for testing using one of the Stripe SDKs. This allows new team members to familiarize themselves quickly with the solution’s payment workflows and understand the integration points without waiting for production access.\n\n## Preparing a Sandbox\n\nFor a given live Stripe account, there can be up to 5 sandboxes. To create a sandbox for onboarding, open the account selection menu in the top left corner of the Stripe Dashboard and select **Sandboxes**. \n\n![](/images/reusable-dev-environments-sandboxes/01.png)\n\nIn the **Create a new sandbox** dialog, the only requirement is to provide a unique name for the sandbox. Optionally, settings from the live account can be [copied](https://docs.stripe.com/sandboxes/dashboard/sandbox-settings) into the sandbox to help minimize setup time even more. \n\n![](/images/reusable-dev-environments-sandboxes/02.png)\n\nAccount settings are not synchronized between sandboxes and their associated live accounts. This means that further changes can be made to sandbox settings to try out new behaviors without affecting other environments.\n\nThe information copied from the production account does not include any customer, product, or transaction data. It can be beneficial if your new team members had some fake data to play around with in the sandbox. The two most common ways of doing this are by using either the [fixtures feature](https://docs.stripe.com/cli/fixtures) in the [Stripe CLI](https://docs.stripe.com/stripe-cli) or one of the supported [language SDKs](https://docs.stripe.com/libraries). The following code samples demonstrate how to use C# and [Stripe.net](https://github.com/stripe/stripe-dotnet) SDK to populate the sandbox account with fake product data.\n\nBefore making requests using any Stripe SDK, you first have to retrieve the secret key for the account that will be used to authenticate API requests for the given environment. Using the **Developers** menu in the top right navigation in the Dashboard, select **API Keys** and **Reveal test key** to get access to the secret key. \n\n![](/images/reusable-dev-environments-sandboxes/03.png)\n\nIn your .NET project, install [Stripe.net](https://www.nuget.org/packages/Stripe.net/) as well as the [Bogus](https://www.nuget.org/packages/Bogus) library that is used to create the fake data. The following code uses the Faker class from Bogus to create a list of random products. \n\n```csharp\n// Generate Fake product data\nusing Bogus;\n\n\npublic record Product(string UniqueCode, string Name, string Description, string ImageUrl, decimal Price);\n\n\npublic class ProductRecordFaker : Faker<Product>\n{\n  public ProductRecordFaker()\n  {\n     this.CustomInstantiator(_ => FormatterServices.GetUninitializedObject(typeof(Product)) as Product);\n     RuleFor(p => p.UniqueCode, f => f.Random.AlphaNumeric(7).ToUpper());\n     RuleFor(p => p.Name, f => f.Commerce.ProductName());\n     RuleFor(p => p.Description, f => $\"This is such an awesome product made out of {f.Commerce.ProductMaterial()}\");\n     RuleFor(p => p.ImageUrl, f => f.Image.PicsumUrl());\n     RuleFor(p => p.Price, f => Decimal.Parse(f.Commerce.Price(min:15, max:200)));\n  }\n}\n\n\nvar productFaker = new ProductRecordFaker();\nvar products = productFaker.Generate(10);\n```\n\nNext, loop through those fake products and pass them to the ProductService in Stripe.net to create Stripe products  in the sandbox.\n\n```csharp\n// Set your secret key\nStripeConfiguration.ApiKey = “sk_test_xxx”;\n\n\n// Create products using the generated fake data\nvar service = new ProductService();\nforeach(var product in products) {\n  \n   var options = new ProductCreateOptions\n   {\n       Name = product.Name,\n       Description = product.Description,\n       Images = new List<string>{ product.ImageUrl},\n       Shippable = true,\n       Metadata = new Dictionary <string, string>{\n           [\"code\"] = product.UniqueCode\n       }\n   };\n  \n   await service.CreateAsync(options);\n}\n```\nAfter running this code, the [Product catalog](https://dashboard.stripe.com/test/products) in the Dashboard has new product data available. Depending on your use case, the SDKs can be used to further populate additional data in the account such as customer information, product pricing, and transaction records.  \n\n## Configuring the development environment \n\nNow that a sandbox has been created for the Stripe account, the next phase involves setting up a reusable developer environment that can be used by the existing team members as well as engineers being onboarded. Companies like [Microsoft](https://azure.microsoft.com/en-us/products/dev-box/), [GitPod](https://www.gitpod.io/), and [GitHub](https://github.com/features/codespaces) all provide scalable offerings for cloud-based development environments (CDEs) that can be hosted for you or you can host yourself. This section shows how to configure an environment using [development containers](https://containers.dev/).\n\nWith development containers, you can create full featured development environments that contain all the tools, libraries and services needed to work on a software project. Using container runtimes, like [Docker](https://www.docker.com/), allows development containers to create isolated environments that can run locally or remotely. This provides engineers with the flexibility to have a consistent workspace even if they change development machines. This approach safeguards the local filesystem since all dependencies are installed within the container, easing setup concerns and ensuring a seamless development experience for everyone on the team. \n\nSource code editors like [Visual Studio Code](https://code.visualstudio.com/) provide [extensions](https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-containers) that enable the use of development containers within a workspace. The following screenshot shows the layout of a sample .NET API project. It relies on a .env file to retrieve the configuration information such as the Stripe secret key and connection credentials to [Redis](https://redis.io/docs/latest/get-started/).\n\n![](/images/reusable-dev-environments-sandboxes/04.png)\n\nTo add development container support to this project, first make sure you have both Docker and the [Dev Containers](https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-containers) extension for Visual Studio Code installed. In the project’s root folder, add a **.devcontainer/devcontainer.json** file which defines the settings for the container workspace. A list of supported properties can be found in the development container [metadata reference](https://containers.dev/implementors/json_reference/) page.  \n\nBelow sample shows the configurations of your development container including how you can customize your environment with “customizations” property. This defines the name of the workspace, the folder path VS Code opens inside of the development container when the environment is running, and VS Code specific extensions that should be installed within the workspace. \n\n```json\n{\n   \"name\": \"Products API (Dev)\",\n\n\n   // The path VS Code should open by default when connected.\n   \"workspaceFolder\": \"/workspace\",\n  \n   \"customizations\": {\n       \"vscode\": {\n           \"extensions\": [\n               \"ms-dotnettools.vscode-dotnet-pack\",\n               \"ms-dotnettools.csdevkit\",\n               \"humao.rest-client\",\n               \"Stripe.vscode-stripe\"\n           ]\n       }\n   }\n}\n```\n\nFor the next step, you need to add configuration for the container image that is used to run the project code. You can think of a container image like a blueprint for a miniature operating system with its own file system and processes running in an isolated space. Before running a dev container, you first have to create a blueprint. \n\nIn Docker, multiple images can be customized and run with a Docker compose file. With this project depending on Redis, an instance of a Redis server should be included in the workspace environment as well. Within the .devcontainer folder, create a compose.yml and include the following configuration.\n\n```yaml\nservices:\n redis:\n   image: \"redis/redis-stack:7.4.0-v0\"\n   ports:\n     - \"6379:6379\"\n     - \"8001:8001\"\n   environment:\n     - REDIS_ARGS=\"--requirepass ${REDIS_PSWD}\"\n```\n\nThe snippet above defines a [Redis](https://redis.io/) service using the [redis/redis-stack image](https://hub.docker.com/r/redis/redis-stack), exposes two ports for communication, and sets the server password with an environment variable. \n\nSince the project is built on .NET, the image must have the correct versions of the .NET runtime and SDK installed. While you are free to create your own image, the development containers [images repository](https://github.com/devcontainers/images) on GitHub hosts a collection of reusable container images for you to  get started with. You can use one of the .NET develpment container [images](https://github.com/devcontainers/images/tree/main/src/dotnet) that already has the SDK installed as the baseline to build on. The configuration below shows how to define a docker compose service for this API project.\n\n```yaml\n productsapi:\n   image: mcr.microsoft.com/devcontainers/dotnet:1-8.0-bookworm\n   volumes:\n     - ..:/workspace:cached\n   command: sleep infinity\n   network_mode: service:redis\n```\n\nThe service configuration uses a container image based on Debian ([bookworm](https://www.debian.org/releases/bookworm/)) and has the .NET 8 SDK included. It mounts the root project directory into the /workspace folder of the container, and configures the network. Redis is now available via localhost inside the development container. A completed version of the compose.yml resembles the following.\n\n```yaml\nservices:\n productsapi:\n   image: mcr.microsoft.com/devcontainers/dotnet:1-8.0-bookworm\n   volumes:\n     - .:/workspace:cached\n   command: sleep infinity\n   network_mode: service:redis\n\n\n redis:\n   image: \"redis/redis-stack:7.4.0-v0\"\n   restart: unless-stopped\n   ports:\n     - \"6379:6379\"\n     - \"8001:8001\"\n   environment:\n     - REDIS_ARGS=\"--requirepass ${REDIS_PSWD}\"\n```\n\nIn the .devcontainer.json file, update the development container settings to use the compose file.\n\n```json\n{\n   \"name\": \"Products API (Dev)\",\n   // The compose files to use for your service\n   \"dockerComposeFile\": [     \n       \"compose.yml\"\n   ],\n   // The name of the service for the container that VS Code should use.\n   \"service\": \"productsapi\",\n  \n   // Tthe path VS Code should open by default when connected.\n   \"workspaceFolder\": \"/workspace\",\n  \n   // Use 'forwardPorts' to make a list of ports inside the container available locally.\n   \"forwardPorts\": [\n       5064\n   ],\n\n\n   \"customizations\": {\n       \"vscode\": {\n           \"extensions\": [\n               \"ms-dotnettools.vscode-dotnet-pack\",\n               \"ms-dotnettools.csdevkit\",\n               \"humao.rest-client\",\n               \"Stripe.vscode-stripe\"\n           ]\n       }\n   }\n}\n```\n\nWith Docker running, use the command palette in Visual Studio Code to run the **Dev Containers: Reopen in Container** command. In a few minutes, the development container runs with the API project mounted into the workspace.\n\n## Adding the Stripe CLI to the workspace\n\nThe VS Code customizations section above installs the Stripe extension into the workspace. For the extension to work, it requires the Stripe CLI to be installed and available on the command path. You can manually install Stripe CLI yourself with the [apt](https://docs.stripe.com/stripe-cli#install) command, or use bash shell script to install it automatically \n\nDevelopment containers allow scripts to be run at different stages of the [lifecycle](https://containers.dev/implementors/json_reference/#lifecycle-scripts). This means you can write bash scripts that run after the container is created to install the Stripe CLI. In the .devcontainer.json file, add the following property.\n\n```json\n \"postCreateCommand\": \"bash .devcontainer/postCreate.sh\"\n```\n\nIn the .devcontainer folder, create a file named postCreate.sh with the following contents.\n\n```bash\n#!/bin/bash\n\n\n# Add Stripe CLI to sources list\necho \"Installing Stripe CLI...\"\ncurl -s https://packages.stripe.dev/api/security/keypair/stripe-cli-gpg/public | gpg --dearmor | sudo tee /usr/share/keyrings/stripe.gpg\necho \"deb [signed-by=/usr/share/keyrings/stripe.gpg] https://packages.stripe.dev/stripe-cli-debian-local stable main\" | sudo tee -a /etc/apt/sources.list.d/stripe.list\n\n\n# Install dependencies\nsudo apt update\nsudo apt install stripe\n```\n\nUsing the command palette in Visual Studio Code to run the **Dev Containers: Rebuild Container** command. This builds a new container image, runs the container, and executes the script.\n\nWith the completed development container configuration, check in these new configuration files into source control. Now all your engineers can work on the project in a completely isolated environment. \n\n## Conclusion\n\nThe less time engineers spend getting their environments configured, the more time for them to make valuable contributions to the team. Spending a little time upfront to build out a consistent development environment for the team can save countless hours battling configuration and versioning issues. Stripe Sandboxes and development containers make an excellent pairing to provide consistent, isolated environments that can benefit the entire team. \n\nTo learn more about developing applications with Stripe, visit our [YouTube Channel](https://www.youtube.com/stripedevelopers).\n","authorBio":"","additionalResources":[{"title":"Stripe CLI","url":"https://docs.stripe.com/stripe-cli"},{"title":"A guide to types of payment methods","url":"https://stripe.com/guides/payment-methods-guide"},{"title":"Stripe Checkout Guide","url":"https://docs.stripe.com/payments/checkout"},{"title":"Workbench Guide","url":"https://docs.stripe.com/workbench"},{"title":"Subscribe to Stripe Developers on YouTube.","url":"https://www.youtube.com/stripedevelopers\""},{"title":"Follow us at @Stripedev on twitter for updates and answers to your developer questions.","url":"https://twitter.com/stripedev"},{"title":"Sign up for the Developer Digest.","url":"https://go.stripe.global/dev-digest"},{"title":"Join the Stripe Discord server to chat live with other developers.","url":"https://discord.com/invite/RuJnSBXrQn"},{"title":"Join Stripe Insiders to try the latest features and provide direct feedback to the teams that build them.","url":"https://insiders.stripe.dev"}],"relatedArticles":[{"slug":"avoiding-test-mode-tangles-with-stripe-sandboxes","title":"Avoiding test mode tangles with Stripe Sandboxes","summary":"Discover how to create independent testing environments with Stripe Sandboxes, streamline your development through GitHub automation, and prioritize the security of your API keys to enhance your payment integration process.","authors":["Ben Smith"],"date":"2024-09-16","type":"Blog","topics":["Sandboxes"],"artConfig":{"ampX":1.1642105275795096,"ampY":0.21234603378855432,"aspectRatio":1.791098642361734,"axis":"y","lump":0.7446210340261474,"count":109.99999999999999,"freq":3.0281107682703468,"isDial":false,"isLineart":false,"isRing":false,"isSpiral":false,"isBalls":false,"isMatrix":false,"left":0,"kaleids":2.5900000000000083,"mouseX":0.6134259259259259,"mouseY":0.7247983870967742,"noise":0,"scale":1.1986845318092938,"top":2,"twirl":0.005405418018509103,"twist":4.438000000000008,"velocity":0.5109999999999996,"shape":"ellipse"}},{"slug":"doing-more-with-less-reducing-requests-to-the-stripe-api","title":"Doing more with less: Reducing requests to the Stripe API","summary":"The performance of an application can directly affect the customer experience. Using the expand feature along with caching techniques, developers can improve the performance of their application by reducing the number of API calls to Stripe.","authors":["Cecil Phillip"],"date":"2024-08-19","type":"Blog","topics":["Workbench"],"artConfig":{"ampX":1.8364052695935116,"ampY":0.7713401032732738,"aspectRatio":1.672809383550465,"axis":"x","lump":0.9759304509066895,"count":91.4999999999999,"freq":5.2168324480928945,"isDial":false,"isLineart":false,"isRing":false,"isSpiral":false,"left":0,"mouseX":0.31886574074074076,"mouseY":0.5007587253414264,"noise":0,"scale":1.293999999999998,"top":0,"twirl":0.1,"twist":51.86400000000122,"velocity":1,"shape":"ellipse"}}]},"authors":[{"name":"Cecil Phillip","slug":"cecil-phillip","profile":"Cecil Phillip is a part of the Developer Relations team at Stripe. He is originally from St. John’s, Antigua and has over a decade of experience in building software for various industries. He’s a huge fan of .NET and loves learning about patterns for building distributed systems. Feel free to reach out to him on social media, and check out some of his videos on the Stripe Developer channel.","posts":[{"slug":"prepare-for-api-upgrades","authorBio":"","title":"Preparing for Stripe API Upgrades","summary":"New Stripe API versions come with new, and sometimes breaking, changes which should be evaluated before upgrading. Stripe Sandboxes and Workbench provide tooling to create isolated workspaces to test applications against these new changes.","authors":["Cecil Phillip"],"date":"2024-10-24","type":"Blog","topics":["Workbench"],"artConfig":{"ampX":0.5330209860971548,"ampY":0.3805387571353413,"aspectRatio":0.41516675978899176,"axis":"x","lump":0,"count":34.20000000000001,"freq":2.19048980999072,"isDial":false,"isLineart":false,"isRing":false,"isSpiral":false,"left":0,"mouseX":0.7386574074074074,"mouseY":0.52,"noise":0,"scale":1.2797443644167636,"top":30,"twirl":0.2139585743169172,"twist":5.989515467478382,"velocity":1,"shape":"rect"}},{"slug":"testing-subscriptions-with-stripe-test-clocks-and-workbench","authorBio":"","title":"Testing  subscriptions with Stripe Test Clocks and Workbench","summary":"Validating payment logic that gets triggered over a period of time is challenging and sometimes results in inelegant solutions.The combination of test clocks and workbench will improve the ability for developers to build and debug recurring payments.","authors":["Cecil Phillip"],"date":"2024-10-14","type":"Blog","topics":["Workbench","Payment Methods"],"artConfig":{"ampX":0.5330209860971548,"ampY":0.3805387571353413,"aspectRatio":0.41516675978899176,"axis":"x","lump":0,"count":34.20000000000001,"freq":2.19048980999072,"isDial":false,"isLineart":false,"isRing":false,"isSpiral":false,"left":0,"mouseX":0.7386574074074074,"mouseY":0.52,"noise":0,"scale":1.2797443644167636,"top":30,"twirl":0.2139585743169172,"twist":5.989515467478382,"velocity":1,"shape":"rect"}},{"slug":"observing-immediate-versus-delayed-payments-with-stripe-workbench","authorBio":"","title":"Observing immediate versus delayed payments with Stripe Workbench","summary":"Immediate and delayed payments need to be handled differently within an integration. It’s important to understand what events to listen for and properties to inspect for relevant changes.","authors":["Cecil Phillip"],"date":"2024-08-23","type":"Blog","topics":["Workbench","Payment Methods"],"artConfig":{"ampX":0.5330209860971548,"ampY":0.3805387571353413,"aspectRatio":0.41516675978899176,"axis":"x","lump":0,"count":34.20000000000001,"freq":2.19048980999072,"isDial":false,"isLineart":false,"isRing":false,"isSpiral":false,"left":0,"mouseX":0.7386574074074074,"mouseY":0.52,"noise":0,"scale":1.2797443644167636,"top":30,"twirl":0.2139585743169172,"twist":5.989515467478382,"velocity":1,"shape":"rect"}},{"slug":"doing-more-with-less-reducing-requests-to-the-stripe-api","authorBio":"","title":"Doing more with less: Reducing requests to the Stripe API","summary":"The performance of an application can directly affect the customer experience. Using the expand feature along with caching techniques, developers can improve the performance of their application by reducing the number of API calls to Stripe.","authors":["Cecil Phillip"],"date":"2024-08-19","type":"Blog","topics":["Workbench"],"artConfig":{"ampX":1.8364052695935116,"ampY":0.7713401032732738,"aspectRatio":1.672809383550465,"axis":"x","lump":0.9759304509066895,"count":91.4999999999999,"freq":5.2168324480928945,"isDial":false,"isLineart":false,"isRing":false,"isSpiral":false,"left":0,"mouseX":0.31886574074074076,"mouseY":0.5007587253414264,"noise":0,"scale":1.293999999999998,"top":0,"twirl":0.1,"twist":51.86400000000122,"velocity":1,"shape":"ellipse"}}]}],"estimatedReadingTime":"7 min read"},"__N_SSG":true}