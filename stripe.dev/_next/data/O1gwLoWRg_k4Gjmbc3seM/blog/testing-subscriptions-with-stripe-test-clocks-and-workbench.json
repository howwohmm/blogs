{"pageProps":{"postData":{"slug":"testing-subscriptions-with-stripe-test-clocks-and-workbench","title":"Testing  subscriptions with Stripe Test Clocks and Workbench","summary":"Validating payment logic that gets triggered over a period of time is challenging and sometimes results in inelegant solutions.The combination of test clocks and workbench will improve the ability for developers to build and debug recurring payments.","authors":["Cecil Phillip"],"date":"2024-10-14","type":"Blog","topics":["Workbench","Payment Methods"],"artConfig":{"ampX":0.5330209860971548,"ampY":0.3805387571353413,"aspectRatio":0.41516675978899176,"axis":"x","lump":0,"count":34.20000000000001,"freq":2.19048980999072,"isDial":false,"isLineart":false,"isRing":false,"isSpiral":false,"left":0,"mouseX":0.7386574074074074,"mouseY":0.52,"noise":0,"scale":1.2797443644167636,"top":30,"twirl":0.2139585743169172,"twist":5.989515467478382,"velocity":1,"shape":"rect"},"content":"\nSubscriptions involve recurring payments that can have billing cycles that span weeks or months. When integrating a subscription feature, you need to be able to trigger scenarios on demand and observe any changes that happen in your system to validate the expected behavior. This becomes challenging for any use case that occurs over large periods of time. Stripe’s test clocks along with Workbench can reduce the time and effort required for verifying your system’s behavior for situations that are dependent on time .\n\nBoth test clocks and Workbench are features available in your account at no additional cost. With test clocks, you simulate the passage of time while your account is in test mode, so you don’t have to wait hours or even days to see how your system behaves. You can observe any state changes and react to any events that get triggered. With Workbench, you have a browser based tool to manage and observe the activities that occur in your Stripe integration.\n\nThis article shows how to use these tools together to ensure your payment integration is ready for production.\n\n### Creating the tiered offerings\n\nBefore setting up a test clock simulation, you should have the subscription offerings provisioned in your product catalog. The screenshot below shows three tiers for customers to choose from. These tiers are modeled as [products](https://docs.stripe.com/products-prices/manage-prices) that each include a unique name, tax category, and a recurring price with a monthly billing period.\n\n![Product catalog](/images/testing-subscriptions-with-testclocks/test-clocks-subscriptions-01.png)\n\n### Setting up the simulation\n\nA test clock is attached to one or more customers and advanced to a target date. This causes any time dependent objects in the Stripe account to update as well, such as subscriptions and webhook events.\n\nTo create a test clock, you have the option of going the no-code route via the Stripe Dashboard, programmatically using the REST API, or using one of the supported language SDKs. The code samples here are written in C\\# and make use of the [Stripe .NET SDK](https://github.com/stripe/stripe-dotnet), but the steps are similar for other languages.\n\nFirst, you need to use the TestClockService class from the SDK to create a new test clock instance. At creation time, a test clock must be given a name and have its [FrozenTime](https://docs.stripe.com/api/test\\_clocks/object?lang=dotnet\\#test\\_clock\\_object-frozen\\_time) property set. This property represents the starting point for the respective clock and is specified as a Unix Epoch timestamp. You can set it to time in the future or in the past, but remember the test clock can only move forward in time after it is created.\n\n```csharp\n    // Retrieve API key from appsettings.json\n    var apiKey = _configuration.GetSection(\"Stripe\")[\"SecretKey\"];\n    var requestOptions = new RequestOptions{ ApiKey = apiKey };       \n      \n    // Create test clock\n    var currentTime = DateTimeOffset.UtcNow.DateTime;\n    var tcCreateOptions = new TestClockCreateOptions\n    {\n        Name = $\"Subscription Clock\",\n        FrozenTime = currentTime\n    };\n\n    var testClockService = new TestClockService();\n    var newTestClock = await testClockService.CreateAsync(tcCreateOptions, requestOptions);\n```\n\nNext, create the customer and subscription objects for the scenario you want to test. Existing customers cannot be used for test clock simulations, but you are able to add up to three new ones. Using the CustomerService class, create a new customer with the Name, Email and PaymentMethod properties assigned.\n\nThe following example uses `pm_card_visa`, which is one of the available [test cards](https://docs.stripe.com/testing\\#cards) that always results in a successful test payment. Also, the `TestClock` property of the new customer must be set at creation time to the ID of the previously created clock.\n\n```csharp\n    // Create a new customer and attach the test clock\n    var ccOptions = new CustomerCreateOptions\n    {\n        Name = \"Fake Customer\",\n        Email = \"customer@fake.com\",\n        Description = \"Faker User Account\",\n        PaymentMethod = \"pm_card_visa\",\n        TestClock = newTestClock.Id,\n        InvoiceSettings = new() { DefaultPaymentMethod = \"pm_card_visa\"}\n    };\n\n    var customerService = new CustomerService();\n    var newCustomer = await customerService.CreateAsync(ccOptions, requestOptions);\n    var originalPMID = newCustomer.InvoiceSettings.DefaultPaymentMethodId;\n```\n\nThe final object to create is the subscription for a test customer. Supply the [SubscriptionService](https://docs.stripe.com/api/subscriptions/create?lang=dotnet) class with the price ID from one of the subscription tiers in the product catalog along with the customer ID.\n\n```csharp\n    // Create a new subscription\n    var priceId = \"<subscription-tier-price-id>\";\n    var options = new SubscriptionCreateOptions\n    {\n        Customer = newCustomer.Id,\n        Items = new List<SubscriptionItemOptions> {\n                new SubscriptionItemOptions {Price = priceId}\n        }\n    };\n\n    var subscriptionService = new SubscriptionService();\n    var newSubscription = await subscriptionService.CreateAsync(options, requestOptions);\n \n```\n\nAfter running the code, you will see that the customer, subscription, and test clock objects all have the option of advancing time for the simulation.\n\n![Advance time highlight](/images/testing-subscriptions-with-testclocks/test-clocks-subscriptions-02.png)\n\nYou can use Workbench to inspect the activity within a Stripe account. It is built into the Stripe Dashboard, so there isn’t anything that needs to be installed. Once it is enabled, you can access the various logs, errors, and events occurring in an account.\n\nInside the **Inspector** tab of Stripe Workbench, you can view details about what has happened with the subscription so far. Looking at the **Logs** and **Events** tab for the subscription reveals a collection of activity, triggered as a result of the code that was executed. These events signal that an initial invoice was paid and the subscription was successfully started. You can even dive deeper into the events and inspect the properties for each of them.\n\n![Workbench Inspector](/images/testing-subscriptions-with-testclocks/test-clocks-subscriptions-03.png)\n\n### Running the simulation\n\nTo move the test clock simulation forward in time, make a call to the [Advance](https://docs.stripe.com/api/test\\_clocks/advance?lang=dotnet) method from the TestClockService and provide it with the future time you want it to progress to. To simulate a billing cycle for a monthly subscription, you must add one month to the initial frozen time the test clock was set to.\n\n```csharp\n    var tcAdvanceOptions = new TestClockAdvanceOptions{ FrozenTime = currentTime.AddMonths(1) };\n    await testClockService.AdvanceAsync(newTestClock.Id, tcAdvanceOptions, requestOptions);\n```\n\nBack in the subscriptions details page in the Stripe Dashboard, the invoice for the subscription is successfully paid and the account is in a new billing period. Opening up the **Events** tab in Stripe Workbench, you can see events for the account like `invoice.created` and `customer.subscription.updated`, and also events for the test clock simulation like `test_helpers.test_clock.ready` and `test_helpers.test_clock.advancing`.\n\n![Workbench Events](/images/testing-subscriptions-with-testclocks/test-clocks-subscriptions-04.png)\n\nThe following example runs a simulation for a failed subscription payment and shows which activities get generated via Workbench.\n\nThe current default payment method for the customer is set to a test card that only returns successful payments. An additional card must be attached to the customer and set as the new default. The `pm_card_chargeCustomerFail` test card is a good option for this.\n\nFirst, use the [Attach](https://docs.stripe.com/api/payment\\_methods/attach?lang=dotnet) method from the PaymentMethodService class to add it as an additional payment method for the customer. Next, update the customer by setting this new payment method as the default.\n\n```csharp\n\n    var pmAttachOptions = new PaymentMethodAttachOptions { Customer = newCustomer.Id };\n\n    var pmService = new PaymentMethodService();\n    var newPaymentMethod = await pmService.AttachAsync(\"pm_card_chargeCustomerFail\", pmAttachOptions, requestOptions);\n\n    var cuOptions = new CustomerUpdateOptions\n    {\n        InvoiceSettings = new() { DefaultPaymentMethod = newPaymentMethod.Id }\n    };\n    await customerService.UpdateAsync(newCustomer.Id, cuOptions, requestOptions);\n\n```\n\nAdvance the test clock simulation to the next billing period.\n\n```csharp\n    var tcAdvanceOptions = new TestClockAdvanceOptions{ FrozenTime = currentTime.AddMonths(2) };\n    await testClockService.AdvanceAsync(newTestClock.Id, tcAdvanceOptions, requestOptions);\n```\n\nIn the subscriptions details page, the fake customer’s subscription shows `canceled` and the last invoice is `failed`. Looking at the triggered events through Workbench displays a number of failed events. Specifically, inspecting the `cancellation_details` property of the `customer.subscription.deleted` event reveals the subscription was canceled because Stripe was unable to collect payment from the customer.\n\nUsing the information collected from these two simulation runs equips you with the insights that help you know what events and properties are important for your application. That also means you know what events you should test for and where to look whenever issues arise in your subscriptions.\n\n### Conclusion\n\nTesting time-sensitive scenarios can be challenging, especially when they extend over long periods. This post shows that tools like Stripe Workbench and test clocks can help validate your development cycle when validating the behavior of your subscription integration.\n\nTo learn more about developing applications with Stripe, visit our [YouTube Channel](https://www.youtube.com/stripedevelopers) and take a look at the additional resources linked below.\n\n","authorBio":"","additionalResources":[{"title":"Workbench","url":"https://docs.stripe.com/workbench"},{"title":"Test Clocks","url":"https://docs.stripe.com/billing/testing/test-clocks"},{"title":"Stripe API docs","url":"https://docs.stripe.com/api"},{"title":"Subscribe to Stripe Developers on YouTube.","url":"https://www.youtube.com/stripedevelopers\""},{"title":"Follow us at @StripeDev on twitter for updates and answers to your developer questions.","url":"https://twitter.com/stripedev"},{"title":"Sign up for the Developer Digest.","url":"https://go.stripe.global/dev-digest"},{"title":"Join the Stripe Discord server to chat live with other developers.","url":"https://discord.com/invite/RuJnSBXrQn"},{"title":"Join Stripe Insiders to try the latest features and provide direct feedback to the teams that build them.","url":"https://insiders.stripe.dev"}],"relatedArticles":[{"slug":"doing-more-with-less-reducing-requests-to-the-stripe-api","title":"Doing more with less: Reducing requests to the Stripe API","summary":"The performance of an application can directly affect the customer experience. Using the expand feature along with caching techniques, developers can improve the performance of their application by reducing the number of API calls to Stripe.","authors":["Cecil Phillip"],"date":"2024-08-19","type":"Blog","topics":["Workbench"],"artConfig":{"ampX":1.8364052695935116,"ampY":0.7713401032732738,"aspectRatio":1.672809383550465,"axis":"x","lump":0.9759304509066895,"count":91.4999999999999,"freq":5.2168324480928945,"isDial":false,"isLineart":false,"isRing":false,"isSpiral":false,"left":0,"mouseX":0.31886574074074076,"mouseY":0.5007587253414264,"noise":0,"scale":1.293999999999998,"top":0,"twirl":0.1,"twist":51.86400000000122,"velocity":1,"shape":"ellipse"}},{"slug":"observing-immediate-versus-delayed-payments-with-stripe-workbench","title":"Observing immediate versus delayed payments with Stripe Workbench","summary":"Immediate and delayed payments need to be handled differently within an integration. It’s important to understand what events to listen for and properties to inspect for relevant changes.","authors":["Cecil Phillip"],"date":"2024-08-23","type":"Blog","topics":["Workbench","Payment Methods"],"artConfig":{"ampX":0.5330209860971548,"ampY":0.3805387571353413,"aspectRatio":0.41516675978899176,"axis":"x","lump":0,"count":34.20000000000001,"freq":2.19048980999072,"isDial":false,"isLineart":false,"isRing":false,"isSpiral":false,"left":0,"mouseX":0.7386574074074074,"mouseY":0.52,"noise":0,"scale":1.2797443644167636,"top":30,"twirl":0.2139585743169172,"twist":5.989515467478382,"velocity":1,"shape":"rect"}}]},"authors":[{"name":"Cecil Phillip","slug":"cecil-phillip","profile":"Cecil Phillip is a part of the Developer Relations team at Stripe. He is originally from St. John’s, Antigua and has over a decade of experience in building software for various industries. He’s a huge fan of .NET and loves learning about patterns for building distributed systems. Feel free to reach out to him on social media, and check out some of his videos on the Stripe Developer channel.","posts":[{"slug":"prepare-for-api-upgrades","authorBio":"","title":"Preparing for Stripe API Upgrades","summary":"New Stripe API versions come with new, and sometimes breaking, changes which should be evaluated before upgrading. Stripe Sandboxes and Workbench provide tooling to create isolated workspaces to test applications against these new changes.","authors":["Cecil Phillip"],"date":"2024-10-24","type":"Blog","topics":["Workbench"],"artConfig":{"ampX":0.5330209860971548,"ampY":0.3805387571353413,"aspectRatio":0.41516675978899176,"axis":"x","lump":0,"count":34.20000000000001,"freq":2.19048980999072,"isDial":false,"isLineart":false,"isRing":false,"isSpiral":false,"left":0,"mouseX":0.7386574074074074,"mouseY":0.52,"noise":0,"scale":1.2797443644167636,"top":30,"twirl":0.2139585743169172,"twist":5.989515467478382,"velocity":1,"shape":"rect"}},{"slug":"creating-reusable-dev-environments-with-sandboxes","authorBio":"","title":"Creating reusable developer environments with Stripe Sandboxes","summary":"When onboarding new team members, getting their development environments setup can be very time consuming. Preprovisioned environments with Stripe sandboxes and development containers can speed up their time to productivity.","authors":["Cecil Phillip"],"date":"2024-10-20","type":"Blog","topics":["Sandboxes"],"artConfig":{"ampX":0.5330209860971548,"ampY":0.3805387571353413,"aspectRatio":0.41516675978899176,"axis":"x","lump":0,"count":34.20000000000001,"freq":2.19048980999072,"isDial":false,"isLineart":false,"isRing":false,"isSpiral":false,"left":0,"mouseX":0.7386574074074074,"mouseY":0.52,"noise":0,"scale":1.2797443644167636,"top":30,"twirl":0.2139585743169172,"twist":5.989515467478382,"velocity":1,"shape":"rect"}},{"slug":"observing-immediate-versus-delayed-payments-with-stripe-workbench","authorBio":"","title":"Observing immediate versus delayed payments with Stripe Workbench","summary":"Immediate and delayed payments need to be handled differently within an integration. It’s important to understand what events to listen for and properties to inspect for relevant changes.","authors":["Cecil Phillip"],"date":"2024-08-23","type":"Blog","topics":["Workbench","Payment Methods"],"artConfig":{"ampX":0.5330209860971548,"ampY":0.3805387571353413,"aspectRatio":0.41516675978899176,"axis":"x","lump":0,"count":34.20000000000001,"freq":2.19048980999072,"isDial":false,"isLineart":false,"isRing":false,"isSpiral":false,"left":0,"mouseX":0.7386574074074074,"mouseY":0.52,"noise":0,"scale":1.2797443644167636,"top":30,"twirl":0.2139585743169172,"twist":5.989515467478382,"velocity":1,"shape":"rect"}},{"slug":"doing-more-with-less-reducing-requests-to-the-stripe-api","authorBio":"","title":"Doing more with less: Reducing requests to the Stripe API","summary":"The performance of an application can directly affect the customer experience. Using the expand feature along with caching techniques, developers can improve the performance of their application by reducing the number of API calls to Stripe.","authors":["Cecil Phillip"],"date":"2024-08-19","type":"Blog","topics":["Workbench"],"artConfig":{"ampX":1.8364052695935116,"ampY":0.7713401032732738,"aspectRatio":1.672809383550465,"axis":"x","lump":0.9759304509066895,"count":91.4999999999999,"freq":5.2168324480928945,"isDial":false,"isLineart":false,"isRing":false,"isSpiral":false,"left":0,"mouseX":0.31886574074074076,"mouseY":0.5007587253414264,"noise":0,"scale":1.293999999999998,"top":0,"twirl":0.1,"twist":51.86400000000122,"velocity":1,"shape":"ellipse"}}]}],"estimatedReadingTime":"5 min read"},"__N_SSG":true}